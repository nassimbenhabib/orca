#include "orca/optim/QPSolverImpl.h"
#include "orca/utils/Logger.h"
#include <osqp.h>
#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <iostream>

namespace orca
{
namespace optim
{

class QPSolverImpl_osqp : public QPSolverImpl
{
private:
    OSQPSettings settings_;
    OSQPWorkspace* work_ = 0;
    OSQPData osqp_data_;
    Eigen::SparseMatrix<double> Ps_;
    Eigen::SparseMatrix<double> As_;
    bool osqp_initialized_ = false;
public:
    virtual ~QPSolverImpl_osqp()
    {
        osqp_cleanup(work_);
        c_free(osqp_data_.A);
        c_free(osqp_data_.P);
    }
    void resize(int nvar,int nconstr)
    {
        if(nvar <= 0 || nconstr <= 0)
            return;
        if(!work_)
        {
            setDefaultOptions();

        }

        Eigen::MatrixXd P(nvar,nvar);
        P.setConstant(1);
        Ps_ = P.sparseView();
        Eigen::MatrixXd A(nconstr,nvar);
        A.setConstant(1);
        As_ = A.sparseView();
        Eigen::VectorXd x(nvar);
        x.setConstant(1);
        Eigen::VectorXd l(nconstr);
        l.setConstant(1);

        osqp_data_.n = nvar;
        osqp_data_.m = nconstr;
        //osqp_data_.P = csc_matrix(data.n, data.n, P_nnz, P_x, P_i, P_p);
        osqp_data_.P = csc_matrix(nvar, nvar, Ps_.nonZeros(), Ps_.valuePtr(), Ps_.innerIndexPtr(), Ps_.outerIndexPtr());
        osqp_data_.q =  x.data();
        osqp_data_.A = csc_matrix(nconstr, nvar, As_.nonZeros(), As_.valuePtr(), As_.innerIndexPtr(), As_.outerIndexPtr());
        osqp_data_.l = l.data();
        osqp_data_.u = l.data();

        // SparseMatrix<double> sparse = dense.sparseView();
        // int m_ = sparse.innerSize(); // number of rows
        // int n_ = sparse.outerSize(); // number of columns
        // int nzmax_ = sparse.nonZeros(); // maximum number of entries (non-zeros)
        // int *p_ = sparse.outerIndexPtr(); // column pointers (size n+1) (col indices (size nzmax)
        // int *i_ = sparse.innerIndexPtr(); // row indices, size nzmax starting from 0
        // double *x_ = sparse.valuePtr();
        LOG_INFO << "[QPSolver] New osqp (nvar=" << nvar << ",nconstr=" <<nconstr<< ")" ;
        work_ = osqp_setup(&osqp_data_, &settings_);
        setPrintLevel(1);
        LOG_INFO << "[QPSolver] osqp setup done" ;
    }

    void setPrintLevel(int level)
    {
        if(!work_)
            throw std::runtime_error("osqp pointer is null");

        osqp_update_verbose(work_,level);
    }

    void setDefaultOptions()
    {
        osqp_set_default_settings(&settings_);
    }

    common::ReturnCode solve(ProblemData& data )
    {
        // osqp_data_.n = n;
        // osqp_data_.m = m;
        // osqp_data_.P = csc_matrix(data.n, data.n, P_nnz, P_x, P_i, P_p);
        // osqp_data_.q = data.g_.data();
        // osqp_data_.A = csc_matrix(data.m, data.n, A_nnz, A_x, A_i, A_p);
        // osqp_data_.l = l;
        // osqp_data_.u = u;
        // osqp_data_.n = nvar;
        // osqp_data_.m = nconstr;
        // osqp_data_.P = csc_matrix(nvar, nvar, Ps.nonZeros(), Ps.valuePtr(), Ps.innerIndexPtr(), Ps.outerIndexPtr());
        // osqp_data_.q =  x.data();
        // osqp_data_.A = csc_matrix(nconstr, nvar, As.nonZeros(), As.valuePtr(), As.innerIndexPtr(), As.outerIndexPtr());
        // osqp_data_.l = l.data();
        // osqp_data_.u = l.data();
        // osqp_update_P
        if(osqp_update_lin_cost(work_,data.g_.data()) != 0)
        {
            std::cerr << "Could not update g" << '\n';
        }
        if(osqp_update_bounds(work_,data.lbA_.data(),data.ubA_.data()) != 0)
        {
            std::cerr << "Could not update bounds" << '\n';
        }

        Eigen::MatrixXd P = data.H_;
        Eigen::MatrixXd A = data.A_;
        Ps_ = P.sparseView();
        As_ = A.sparseView();
        Ps_.makeCompressed();
        As_.makeCompressed();

        if(osqp_update_P_A(work_,Ps_.valuePtr(),
                              Ps_.innerIndexPtr(),
                              Ps_.nonZeros(),
                              As_.valuePtr(),
                              As_.innerIndexPtr(),
                              As_.nonZeros()) != 0)
        {
          std::cerr << "Could not update P and A" << '\n';
        }

        if(!osqp_initialized_)
        {
            osqp_solve(work_);
            if(work_->info->status_val == OSQP_SOLVED)
            {
                osqp_initialized_ = true;
                return common::ReturnCode::SUCCESSFUL_RETURN;
            }
            return common::ReturnCode::RET_QP_NOT_SOLVED;
        }



// solved	OSQP_SOLVED	1
// solved inaccurate	OSQP_SOLVED_INACCURATE	2
// maximum iterations reached	OSQP_MAX_ITER_REACHED	-2
// primal infeasible	OSQP_PRIMAL_INFEASIBLE	-3
// primal infeasible inaccurate	OSQP_PRIMAL_INFEASIBLE_INACCURATE	3
// dual infeasible	OSQP_DUAL_INFEASIBLE	-4
// dual infeasible inaccurate	OSQP_DUAL_INFEASIBLE_INACCURATE	4
// interrupted by user	OSQP_SIGINT	-5
// run time limit reached	OSQP_TIME_LIMIT_REACHED	-6
// unsolved	OSQP_UNSOLVED
//         if(!qpoases_)
//             throw std::runtime_error("qpsolver pointer is null");
//
//         int nWSR = 1000000;
//         qpOASES::returnValue ret;
//
//         if(!qpoases_initialized_)
//         {
//             // Initialise the problem, once it has found a solution, we can hotstart
//             ret = qpoases_->init(   data.H_.data()
//                                         , data.g_.data()
//                                         , data.A_.data()
//                                         , data.lb_.data()
//                                         , data.ub_.data()
//                                         , data.lbA_.data()
//                                         , data.ubA_.data()
//                                         , nWSR
// //                                         , 0 // cputime
// //                                         , 0 // xOpt
// //                                         , 0 // yOpt
// //                                         , &guessedBounds
//                                         );
//
//             // Keep init if it didn't work
//             if(ret == qpOASES::RET_INIT_FAILED)
//                 LOG_WARNING << "[qpoases] Init called but returned code " << ret << ", I will keep trying to init" << '\n';
//             else
//                 qpoases_initialized_ = true;
//         }
//         else
//         {
//             // Otherwise let's reuse the previous solution to find a solution faster
//             ret = qpoases_->hotstart( data.H_.data()
//                                         , data.g_.data()
//                                         , data.A_.data()
//                                         , data.lb_.data()
//                                         , data.ub_.data()
//                                         , data.lbA_.data()
//                                         , data.ubA_.data()
//                                         , nWSR);
//             if(ret != qpOASES::SUCCESSFUL_RETURN)
//             {
//                 qpoases_initialized_ = false;
//                 LOG_WARNING << "[qpoases] Hotstart returned : " << qpOASES::MessageHandling::getErrorCodeMessage(ret) << '\n';
//             }
//
//         }
//         // NOTE : for now, orca return codes == qpoases return code
//         return static_cast<common::ReturnCode>(ret);
    }

    void getPrimalSolution(Eigen::VectorXd& solution)
    {
        if(!work_)
            throw std::runtime_error("osqp pointer is null");

        int nv = work_->data->n;
        if(solution.size() != nv)
        {
            std::stringstream err;
            err << "Provided vector size is " << solution.size() << ",but the number of variable is " << nv << std::endl;
            throw std::runtime_error(err.str());
        }
        solution = Eigen::Map<Eigen::VectorXd>(work_->solution->x, work_->data->n, 1);
    }
};

} // namespace optim
} // namespace orca
